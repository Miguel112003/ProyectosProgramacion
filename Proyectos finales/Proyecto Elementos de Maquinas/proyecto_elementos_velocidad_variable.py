# -*- coding: utf-8 -*-
"""Proyecto Elementos Velocidad Variable.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MzOLS7_sVMRbJ6EjlU4gdzrK_gIQlIqG
"""

import math
import numpy as np
import matplotlib.pyplot as plt
import scipy
import scipy.linalg


#Parametros
w2 = 2.094 #rad/seg
l2 = 0.095 #metros
l3 = 0.45 #metros
m4 = 3 #kg
m2 = 1 #kg
m3 = 2 #kg
Px = 1100 #N

i2 = m2*l2**2 /12
i3 = m3*l3**2 /12


def posicion(theta):
  return l3  - l2**2 /(4*l3) + l2*(np.cos(theta) + l2/(4*l3) * np.cos(2*theta))

def phi(theta): #rad
  return (np.arcsin(l2 *np.sin(theta)/l3))

def Va(theta): #m/s
  return w2 * l2 * np.cos(theta) - (w2 * l2 * np.sin(theta))

def VaX(theta): #m/s (Direccion I)
  return - (w2 * l2 * np.sin(theta))

def VaY(theta): #m/s (Direccion J)
  return w2 * l2 * np.cos(theta)

def w3(theta): #rad/s
  return -(VaY(theta))/(l3*np.cos(phi(theta)))

def Vb(theta): #m/s (Solo va En Dir I)
  return VaX(theta) + w3(theta) * l3 * np.sin(phi(theta))

def aA(theta): #m/s^2
  return -w2**2 * (l2*np.cos(theta)) - (l2*np.sin(theta))

def aAX(theta): #m/s^2 (Direccion I)
  return -w2**2 * (l2*np.cos(theta))

def aAY(theta): #m/s^2 (Direccion J)
  return -w2**2 * (l2*np.sin(theta))

def alfa3(theta): #rad/s^2
  return (-w3(theta)**2 * l3 * np.sin(phi(theta)) - aAY(theta))/(l3*np.cos(phi(theta)))

def aB(theta): #m/s^2 (Solo va en Dir I)
  return aAX(theta) + alfa3(theta) * l3 * np.sin(phi(theta)) - w3(theta)**2 * l3 * np.cos(phi((theta)))

def aBx(theta): #m/s^2 (Va en Dir I)
  return aAX(theta) + alfa3(theta) * l3 * np.sin(phi(theta)) -(w3(theta)**2 * (l3*np.cos(phi(theta))))

def ag2x(theta):
  return -w2**2 * (l2*np.cos(theta)/2)

def ag2y(theta):
  return -w2**2 * (l2*np.sin(theta)/2)

def ag3x(theta):
  return aBx(theta) - alfa3(theta) * (l3*np.sin(phi(theta))/2) - (w3(theta)**2 * (-l3*np.cos(phi(theta))/2))

def ag3y(theta):
  return alfa3(theta) * (-l3*np.cos(phi(theta))/2) - (w3(theta)**2 * (l3*np.sin(phi(theta))/2))

def torque(theta):
  return Px * l2 * np.sin(theta) * (1+l2*np.cos(theta)/l3)

#Ahora planteo la matriz


def crearMatriz(angulo):
  matriz = np.array([[1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0]
                    ,[0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0]
                    ,[-l2*np.sin(angulo)/2 , -l2*np.cos(angulo)/2 , -l2*np.sin(angulo)/2 , l2*np.cos(angulo)/2 , 0.0,0.0,0.0,1.0]
                    ,[0.0,0.0,-1.0,0.0,1.0,0.0,0.0,0.0]
                    ,[0.0,0.0,0.0,-1.0,0.0,1.0,0.0,0.0]
                    ,[0.0,0.0,l3*np.sin(phi(angulo))/2,-(-l3*np.cos(phi(angulo))/2),-(-l3*np.sin(phi(angulo))/2),l3*np.cos(phi(angulo))/2,0.0,0.0]
                    ,[0.0,0.0,0.0,0.0,-1.0,0.0,0.0,0.0]
                    ,[0.0,0.0,0.0,0.0,0.0,-1.0,1.0,0.0]
                    ])
  return matriz

def crearResultado(angulo):
  resultado = np.array([[m2*ag2x(angulo)],[m2*ag2y(angulo)],[0],[m3*ag3x(angulo)],[m3*ag3y(angulo)],[i3*alfa3(angulo)],[m4*aB(angulo) - Px],[0]])
  return resultado



theta = np.linspace(0,5*math.pi,100) #rad
anguloPrueba = math.pi

"""
print(m2)
print(m3)
print(m4)
print(aB(5))
print(ag3x(5))
print(i3)
print(alfa3(5))
print(ag3y(5))
print(ag2x(5))
print(ag2y(5))
"""

#print(np.linalg.solve(crearMatriz(anguloPrueba),crearResultado(anguloPrueba)))
#print()
#print(np.array([["Ox"],["Oy"],["Ax"],["Ay"],["Bx"],["By"],["N"],["T"]]))
#print()


def graficar(vectorX,vectorY):
  color = input("Ingresa el color de la gráfica: ")
  titulo = input("Ingresa el título de la gráfica: ")
  xlabel = input("Ingresa el título del eje X: ")
  ylabel = input("Ingresa el título del eje Y: ")
  plt.plot(vectorX, vectorY, color=color)
  plt.title(titulo)
  plt.xlabel(xlabel)
  plt.ylabel(ylabel)
  plt.grid(True)
  plt.show()


vectorOx = []
vectorOy = []
vectorAx = []
vectorAy = []
vectorBx = []
vectorBy = []
vectorN = []

for i in theta:
  solucion = np.linalg.solve(crearMatriz(i), crearResultado(i))
  vectorOx.append(solucion[0])
  vectorOy.append(solucion[1])
  vectorAx.append(solucion[2])
  vectorAy.append(solucion[3])
  vectorBx.append(solucion[4])
  vectorBy.append(solucion[5])
  vectorN.append(solucion[6])

plt.plot(theta,torque(theta))
plt.grid()
print(max(torque(theta)))
print(min(torque(theta)))

graficar(theta,torque(theta))