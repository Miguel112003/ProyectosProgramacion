{"cells":[{"cell_type":"code","execution_count":1,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"v30ID9OWRid7","executionInfo":{"status":"ok","timestamp":1684008733348,"user_tz":300,"elapsed":5224,"user":{"displayName":"Miguel Bejarano","userId":"03263552714194898498"}},"outputId":"e28d6370-baed-402a-a658-5c93b856bd62"},"outputs":[{"output_type":"stream","name":"stdout","text":["\n","  Recuerde que para modificar los valores de todo se debe ir a la linea 440.\n","  1. Realizar sustitucion hacia atras\n","  2. Realizar susticion hacia adelante\n","  3. Hallar Factorizacion LU\n","  4. Hallar Factorizacion PLU\n","  5. Hallar Valores Propios\n","  6. Descomposicion de Cholesky\n","  7. Norma Vectorial\n","  8. Norma Matricial\n","  9. Metodo Gauss-Seidel\n","  10. Numero Condicional Matriz\n","  11. Solucion de Sistemas por matriz Inversa\n","  12. Solucion de sistemas por Numpy Solve\n","  13. Determinar Matriz Diagonal Dominante\n","  14. Matriz de Hilbert\n","  15. Graficar Dispersion de datos\n","  16. Interpolacion de Newton\n","  17. Interpolacion de Lagrange\n","  0. Salir\n","  \n","Escoja: 11\n","[[-20.]\n"," [ 12.]\n"," [  0.]]\n"]}],"source":["import math\n","import numpy as np\n","import scipy\n","import scipy.linalg \n","import matplotlib.pyplot as plt\n","import sympy\n","from scipy.interpolate import CubicSpline\n","# En los casos de factorizacion se utiliza Pivoteo Parcial\n","def menu():\n","  print(\"\"\"\n","  Recuerde que para modificar los valores de todo se debe ir a la linea 440.\n","  1. Realizar sustitucion hacia atras\n","  2. Realizar susticion hacia adelante\n","  3. Hallar Factorizacion LU\n","  4. Hallar Factorizacion PLU\n","  5. Hallar Valores Propios\n","  6. Descomposicion de Cholesky\n","  7. Norma Vectorial\n","  8. Norma Matricial\n","  9. Metodo Gauss-Seidel\n","  10. Numero Condicional Matriz\n","  11. Solucion de Sistemas por matriz Inversa\n","  12. Solucion de sistemas por Numpy Solve\n","  13. Determinar Matriz Diagonal Dominante\n","  14. Matriz de Hilbert\n","  15. Graficar Dispersion de datos\n","  16. Interpolacion de Newton\n","  17. Interpolacion de Lagrange\n","  0. Salir\n","  \"\"\")\n","  eleccion = int(input(\"Escoja: \"))\n","  return eleccion\n","\n","def backsusti(matriz,resultado):\n","  tamaño = np.shape(matriz)\n","  n = tamaño[0]\n","  if tamaño[0] != tamaño[1] :\n","    print(\"La matriz no es triangular\")\n","  else:\n","    print(\"La matriz es triangular, realizando sustitucion\")\n","    x = np.zeros((n,1))\n","    x[n-1,0] = resultado[n-1,0] / matriz[n-1,n-1]\n","    i = n-2\n","    while i >= 0:\n","      sumatoria = 0\n","      j = i + 1\n","      while j <= n-1:\n","        sumatoria = sumatoria + matriz[i,j] * x[j,0]\n","        j += 1\n","      x[i,0] =  (resultado[i,0] - sumatoria) / matriz[i,i]\n","      i -= 1\n","  print(\"La solucion hallada es: \\n\")\n","  return x\n","\n","def frontsusti(matriz,resultado):\n","  tamaño = np.shape(matriz)\n","  n = tamaño[0]\n","  if tamaño[0] != tamaño [1]:\n","    print(\"La matriz no es triangular\")\n","  else:\n","    print(\"Realizando sustitucion\")\n","    x = np.zeros((n,1))\n","    x[0,0] = resultado[0,0] / matriz[0,0]\n","    i = 1\n","    while i <= n-1:\n","      j = 0\n","      sumatoria = 0\n","      while j <= n-1:\n","        sumatoria = sumatoria + matriz[i,j] * x[j,0]\n","        j +=1\n","      x[i,0] = (resultado[i,0] - sumatoria) / matriz[i,i]\n","      i += 1\n","    return x\n","\n","def diagonalDominante(matriz):\n","  n = np.shape(matriz)[0]\n","  for i in range(0, n) :\n","    sum = 0\n","    for j in range(0, n) :\n","      sum = sum + abs(matriz[i][j])\n","    sum = sum - abs(matriz[i][i])\n","    if (abs(matriz[i][i]) < sum) :\n","      return False\n","  return True\n","\n","\n","def diagonalDominanteColumnas(matriz):\n","  n = np.shape(matriz)[0]\n","  for i in range(0,n):\n","    suma = 0\n","    for j in range(0,n): \n","      suma = suma + abs(matriz[j,i])\n","    suma = suma - abs(matriz[i,i])\n","    if matriz[i,i] < suma :\n","        print(\"No es diagonaldominante\")\n","    else:\n","      print(\"Es diagonaldominante\")  \n","    \n","\n","def factolu(matriz):\n","\n","  if diagonalDominante(matriz) == False:\n","    if not matriz.shape[0] == matriz.shape[1]:\n","      raise ValueError(\"La matriz debe ser cuadrada\")\n","    n = matriz.shape[0] \n","    L = np.zeros((n,n),dtype='float64') \n","    U = np.zeros((n,n),dtype='float64') \n","    U[:] = matriz \n","    np.fill_diagonal(L,1)\n","    for i in range(n-1):\n","      for j in range(i+1,n):\n","        L[j,i] = U[j,i]/U[i,i]\n","        U[j,i:] = U[j,i:]-L[j,i]*U[i,i:]\n","        U[j,i] = 0\n","      \n","    print(\"Matriz Lower: \\n\", L, \"\\n\")\n","    print(\"Matriz Upper: \\n\", U, \"\\n\")\n","\n","    print(\"Ahora para resolver el sistema post descomposicion usamos Hacia adelante: \\n\")\n","    y = frontsusti(L,resultado)\n","    print(y,\"\\n\")\n","    print(\"Matriz original: \\n\")\n","    print(np.matmul(L,U), \"\\n\")\n","    print(\"Ahora usando el vector que acabamos de obtener resolvemos el sistema Original con hacia atras y la Upper: \\n\")\n","    incognitas = backsusti(U, y)\n","\n","    print(incognitas,\"\\n\")\n","    print(\"Esas son las incogitas del sistema\\n\")\n","  else:\n","    print(\"La matriz no es diagonal Dominante, realice PLU\")\n","\n","\n","def factoplu(matriz,resultado):\n","  n = np.shape(matriz)[0]\n","  P, L, U = scipy.linalg.lu(matriz)\n","  print(\"Matriz de permutacion: \\n\", P, \"\\n\")\n","  print(\"Matriz Lower: \\n\", L, \"\\n\")\n","  print(\"Matriz Upper: \\n\", U, \"\\n\")\n","\n","  #Ahora toca resolver el sistema para lo que calculamos un C\n","  print(\"Vector resultado permutado: \\n\")\n","  c = np.matmul(P,resultado)\n","  print(c, \"\\n\")\n","  # Aqui solucionamos L*INCOGNITAS = C con sustitucion hacia adelante\n","  print(\"Vector de incognitas obtenido: \\n\")\n","  d = frontsusti(L,c)\n","  print(d, \"\\n\")\n","  # Aqui solucionamos U*IncognitasOriginales = d con hacia atras\n","  print(backsusti(U,d))\n","  print(\"Esa es la solucion del sistema original hecho por PLU\")\n","\n","def valorespropios(matriz):\n","  eigenval,eigenvect = np.linalg.eig(matriz)\n","  return eigenval\n","\n","def cholesky(matriz):\n","  if np.shape(matriz)[0] == np.shape(matriz)[1]:\n","    print(\"La matriz es cuadrada\")\n","    iguales = (matriz == np.transpose(matriz)).all()\n","    if iguales == True:\n","      print(\"La matriz es simetrica\")\n","      for i in range (len(valorespropios(matriz))):\n","        if valorespropios(matriz)[i] >= 0:\n","          positiva = True\n","        else:\n","          positiva = False\n","  if positiva == True:\n","    print(\"Sus valores propios son positivos y reales\\n\")\n","    L = np.linalg.cholesky(matriz)\n","    Lt = np.transpose(L)\n","    print(\"La matriz L es: \\n\", L, \"\\n\")\n","    print(\"La matriz L^t es: \\n\", Lt, \"\\n\")\n","    print(\"La matriz original es: \\n\")\n","    print(np.matmul(L,Lt),\"\\n\")\n","    \n","    #Ahora toca resolver L*Incognitas = resultado con sustitucion hacia adelante\n","    y = frontsusti(L,resultado)\n","    print(\"El vector de incognitas calculado es: \\n\",y)\n","    #Ahora se resuelve el sistema Lt*IncognitasOriginales = IncognitasAnteriores con sustitucion hacia atras\n","    print(backsusti(Lt,y),\"\\n\")\n","    print(\"Esa es la solucion del sistema original, mediante factorizacion Cholesky\")\n","\n","\n","def normavector(vector):\n","  print(\"Por si no recuerda, la norma 2 es la norma que uno estudia en Vectores, la raiz de las componentes al cuadrado\")\n","  orden = int(input(\"Ingrese el orden de la norma (1 o 2) Ponga 3 para norma inf: \"))\n","  if orden == 3:\n","    orden = np.inf\n","  print(scipy.linalg.norm(vector,ord=orden))\n","\n","def normamatriz(matriz):\n","  print(\"\"\"Escoja Norma:\n","  1. Norma 1\n","  2. Norma Infinita\n","  3. Norma de Frobenius\n","  4. Norma 2\"\"\")\n","  eleccion = int(input())\n","  if eleccion == 3:\n","    norma = 0\n","    sumatoria = 0\n","    i = 1\n","    while i < n:\n","      j = 1\n","      while j < n:\n","        sumatoria = sumatoria + matriz[i,j]**2\n","        j += 1\n","      i += 1\n","    norma = (sumatoria**(1/2))\n","    print(\"La norma matricial 2 es: \")\n","    return norma\n","  elif eleccion == 1:\n","    print(\"La norma matricial 2 es: \")\n","    return scipy.linalg.norm(matriz, 1)\n","  elif eleccion  == 2:\n","    print(\"La norma matricial 2 es: \")\n","    return scipy.linalg.norm(matriz, np.inf)\n","  else:\n","    p = np.linalg.eig(np.matmul(matriz,np.transpose(matriz)))\n","    n = np.shape(np.matmul(matriz,np.transpose(matriz)))[1]\n","    i = 0\n","    while i < n-1:\n","      if abs(p[i]) > abs(p[i-1]):\n","        maximo = abs(p[i])\n","      i += 1\n","    norma = (maximo**(1/2))\n","    print(\"La norma matricial 2 es: \")\n","    return norma\n","\n","def gauss_seidel(matriz,resultado, condicion):\n","  print(matriz, \"\\n\")\n","  print(resultado, \"\\n\")\n","  n = int(input(\"Ingrese la cantidad de interaciones: \"))\n","  tolerancia = int(input(\"Ingrese el exponente de la tolerancia 10^(): \"))\n","  tol = 10**tolerancia\n","  [n,n]=np.shape(matriz)\n","  k=1\n","  while k<=n: # iteraciones\n","    i=0\n","    x1=condicion # para aplicar la tolerancia\n","    while i<=n-1: #hallar los x_i\n","      su=0\n","      j=0\n","      while j<=n-1: #sumatoria\n","        if i==j:\n","          su=su\n","        else:\n","          su=su+matriz[i,j]*x1[j,0]\n","        j=j+1\n","      x1[i,0]=(resultado[i,0]-su)/matriz[i,i]\n","      i=i+1\n","    if scipy.linalg.norm(condicion-x1, ord=1)<=tol:\n","      break\n","    condicion=x1\n","    k=k+1\n","  return(x1)\n","  \n","def numerocondicional(matriz):\n","  numcond1 = (scipy.linalg.norm(matriz, ord=1) * scipy.linalg.norm(np.linalg.inv(matriz), ord=1))\n","  numcond2 = (scipy.linalg.norm(matriz, ord=2) * scipy.linalg.norm(np.linalg.inv(matriz), ord=2))\n","  numcond3 = (scipy.linalg.norm(matriz, ord=np.inf) * scipy.linalg.norm(np.linalg.inv(matriz), ord=np.inf))\n","  print(numcond1, numcond2, numcond3)\n","  return numcond1, numcond2, numcond3\n","\n","def solucioninversa(matriz, resultado):\n","  inversa = np.linalg.inv(matriz)\n","  resultado = np.matmul(inversa,resultado)\n","  print(resultado)\n","  return resultado\n","\n","def numpysolve(matriz, resultado):\n","  solucion = np.linalg.solve(matriz,resultado)\n","  print(solucion)\n","  return solucion\n","\n","def hilbert():\n","  orden = int(input(\"Ingrese el tamaño de la matriz: \"))\n","  orden = orden -1\n","  h = np.eye(orden+1)\n","  i = 0\n","  while i < orden+1:\n","    j = 0\n","    while j < orden+1:\n","      h[i,j] = 1/(i+1+j+1-1)\n","      j += 1\n","    i += 1\n","\n","  print(\"La matriz de hilbert calculada es: \\n\", h, \"\\n\")\n","  #Aqui resuelvo el sistema H*Incognitas = Resultado\n","\n","  matriz = h\n","  numpysolve(matriz,resultado)\n","  return h\n","\n","def graficarDatos(ordenada,abscisa):\n","  plt.figure(figsize = [6,6], facecolor = \"white\")\n","  plt.plot(abscisa,ordenada, \"rs\", label = \"Dispersion de Datos\", color = \"r\")\n","  plt.xlabel(\"Eje X\")\n","  plt.ylabel(\"Eje Y\")\n","  plt.grid()\n","  plt.legend(title_fontsize = 20, loc = \"center left\")\n","  plt.show()\n","\n","def Linterpol(ordenada,abscisa):\n","  print(\"Se va a calcular una interpolacion para los siguientes datos: \")\n","  graficarDatos(ordenada,abscisa)\n","  n = np.shape(ordenada)[0]\n","  L = np.zeros((n,n))\n","  for c in range(n):\n","    L[c,0] = 1\n","  v = 1\n","  while v < n:\n","    L[0,v] = 0\n","    v += 1\n","  i = 1\n","  while i < n:\n","    j = 1\n","    while j < n:\n","      k = 0\n","      productoria = 1\n","      while k<j:\n","        productoria *= (abscisa[i]-abscisa[k])\n","        k += 1\n","      L[i,j] = productoria\n","      j += 1\n","    i += 1\n","  print(\"La matriz del polinomio interpolador hallada es: \\n\")\n","  print(L, \"\\n\")\n","\n","  #Ahora toca probar el sistema L*ABSCISA = ORDENADA\n","  print(\"Los coeficientes hallados son: \")\n","  coeficientes = numpysolve(L,ordenada)\n","  #Ahora sacamos el polinomio interpolador\n","  x = sympy.Symbol('x')\n","  i = 1\n","  polinomio = 0\n","  while i < n:\n","    productoria = 1 \n","    j = 0\n","    while j < i:\n","      productoria *= (x-abscisa[j])\n","      j += 1\n","    polinomio = polinomio + (coeficientes[i] * productoria)\n","    i += 1\n","  polinomio = polinomio + coeficientes[0]\n","  print(\"El polinomio Interpolador de Newton hallado es: \", polinomio, \"\\n\")\n","  return polinomio\n","\n","def extrapolarNewt():\n","  punto = float(input(\"Ingrese un valor X para extrapolar: \"))\n","  x = sympy.Symbol('x')\n","  polinomio = Linterpol(ordenada,abscisa)\n","  print(\"El valor extrapolado es: \")\n","  print(polinomio[0].subs(x,punto))\n","  seleccion = int(input(\"Desea graficar el Polinomio para ver si corta al dato? (1. Si, 2. No)\"))\n","  if seleccion == 1:\n","    a = float(input(\"Ingrese el primer valor del intervalo a graficar: \"))\n","    b = float(input(\"Ingrese ell segundo valor del intervalo a graficar: \"))\n","    independientes = np.linspace(a,b,50)\n","    dependientes = np.zeros_like(independientes)\n","    for i in range(50):\n","      dependientes[i] = polinomio[0].subs(x, independientes[i])\n","    plt.figure(figsize = [6,6], facecolor = \"white\")\n","    plt.plot(independientes,dependientes, label = \"Polinomio\", color = \"b\")\n","    plt.xlabel(\"Eje X\")\n","    plt.ylabel(\"Eje Y\")\n","    plt.grid()\n","    plt.legend(title_fontsize = 20, loc = \"center left\")\n","    plt.show()\n","  else:\n","    return \":D\"\n","\n","def lagrangeinterpol(abscisa, ordenada):\n","  xp = float(input(\"Ingrese el valor para extrapolar: \"))\n","  yp = 0\n","\n","  for xi,yi in zip(abscisa,ordenada):\n","    #yp += yi * np.prod((xp - x[x != xi])/(xi-x[x != xi]))\n","  #print('Interpolated value at %.3f is %.3f.' % (xp, yp))\n","    print(\"0\")\n","  return 0\n","\n","def main():\n","  eleccion = menu()\n","  if eleccion == 0:\n","    exit()\n","  elif eleccion == 1:\n","    print(backsusti(matriz,resultado))\n","  elif eleccion == 2:\n","    print(frontsusti(matriz,resultado))\n","  elif eleccion == 3:\n","    factolu(matriz)\n","  elif eleccion == 4:\n","    factoplu(matriz,resultado)\n","  elif eleccion == 5:\n","    print(valorespropios(matriz))\n","    print(\"Toma en cuenta que esos valores propios estan en forma a+b*i, i=raiz(-1)\")\n","    print(\"Por lo tanto es importante ver si el valor es a+0i, eso significa que es solo real\")\n","  elif eleccion == 6:\n","    cholesky(matriz)\n","  elif eleccion == 7:\n","    normavector(vector)\n","  elif eleccion == 8:\n","    normamatriz(matriz)\n","  elif eleccion == 9:\n","    print(\"ESTE METODO LO HICIMOS MAL EN CLASE, NO LO UTILICE, Y USE EL CODIGO DEL BLOQUE SIGUIENTE\")\n","    print(gauss_seidel(matriz,resultado,condicion))\n","  elif eleccion == 10:\n","    print(\"El numero condicional es como la relacion entre los cambios de una variable con su imagen\")\n","    print(\"Es decir haga de cuenta una funcion f(X) si x cambia poquito y f(x) cambia poquito tambien\")\n","    print(\"Entonces esta bien condicionada, si cambios pequeños en x generan cambios grandes, mal condicionada\")\n","    print(\"Esto sirve para relacionar matrices con cambios minimos\")\n","    numerocondicional(matriz)\n","  elif eleccion == 11:\n","    solucioninversa(matriz,resultado)\n","  elif eleccion == 12:\n","    numpysolve(matriz,resultado)\n","  elif eleccion == 13:\n","    print(diagonalDominante(matriz))\n","  elif eleccion == 14:\n","    hilbert()\n","  elif eleccion == 15:\n","    graficarDatos(ordenada,abscisa)\n","  elif eleccion == 16:\n","    opcion = int(input(\"Quiere extrapolar (Ponga 1) o solo conocer el polinomio? (Ponga 2): \"))\n","    if opcion == 1:\n","      extrapolarNewt()\n","    else:\n","      Linterpol(abscisa, ordenada)\n","  elif eleccion == 17:\n","    print(lagrangeinterpol(abscisa, ordenada))\n","  else:\n","    print(\"No tenemos eso, le ofrezco el menu\")\n","    eleccion = menu()\n","\n","\n","\"\"\"Aqui ya tenes que modificar los datos necesarios para el desarrollo de los ejercicios\"\"\"\n","\n","vector = np.array([2,15,-3,1,10,0,2,2])\n","\n","matriz = np.array([[0,1,1],[1,3,1],[1,1,3]])\n","resultado = np.array([[12],[16],[-8]])\n","\n","condicion = np.array([[0],[0],[0]])\n","\n","abscisa = np.array([[10],[15],[20],[25],[40],[50],[55]])\n","ordenada = np.array([5,20,18,40,33,54,70])\n","\n","#Abcisas es X y las ordendas son Y\n","#La de resultado es el vector al que se iguala un sistema de ecuaciones\n","#Condicion es el vector de condiciones iniciales para el metodo de Gauss-Seidel ya que este es el que aproxima\n","#Vector es simplemente un vector como para calcular norma o algo asi\n","#matriz es la matriz que estas utilizando\n","\n","#Aqui se ejecuta el codigo\n","\n","main()"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":293,"status":"ok","timestamp":1666757983015,"user":{"displayName":"Miguel Bejarano","userId":"03263552714194898498"},"user_tz":300},"id":"KPfUg7fA_hBH","outputId":"3ace436b-5b93-47da-e772-939b6572d830"},"outputs":[{"name":"stdout","output_type":"stream","text":["Estos son los valores de la segunda derivada para los datos: \n","[[ 0.03773325]\n"," [-0.00796426]\n"," [ 0.00921755]\n"," [ 0.0028753 ]] \n","\n","Ahora toca calcular los Polinomios para los intervalos que requerimos interpolar\n","Usando la forma analitica obtenemos los polinomios: \n","\n","P2 = -0.000952031458*x**3 + 0.04171538*x**2 - 0.776284026667*x + 15.510928\n","P4 = -0.000132130208*x**3 + 0.01412215*x**2 - 0.617081066667*x + 16.9201552 \n","\n","Evaluando en los puntos conocidos para probar nuestros polinomios: \n","11.483000000168 \n"," 9.870000001360001 \n","\n","Y para el P4 \n","\n","8.4180000046 \n"," 7.305000010912 \n","\n","Finalmente extrapolando en X=10 y X=27 con sus polinomios respectivos\n","10.967594275329999 \n"," 7.953294865926999\n","Ahora comparamos con el metodo de Scipy\n","10.967594273325359\n","7.953294847114234 \n","\n","Como podemos ver el valor es el mismo, lo que nos idica que esta correcto\n"]}],"source":["from scipy.interpolate import CubicSpline\n","import numpy as np\n","\n","\n","def mat_spline(x,y):\n","    n=np.shape(x)[0] \n","    A=np.zeros((n-2,n-2))\n","    c=np.zeros((n-2,1))\n","    i=0\n","    while i<=(n-2)-1: \n","          j=0\n","          while j<=(n-2)-1:\n","                if i==j:\n","                   A[i,j]=2*(x[i+2,0]-x[i,0])\n","                elif i==j+1:\n","                   A[i,j]=x[i+1,0]-x[i,0]\n","                elif j==i+1:\n","                   A[i,j]=x[i+2,0]-x[i+1,0]\n","                j=j+1\n","          c[i,0]=6/(x[i+2,0]-x[i+1,0])*(y[i+2,0]-y[i+1,0])+6/(x[i+1,0]-x[i,0])*(y[i,0]-y[i+1,0])\n","          i=i+1\n","    PP=np.linalg.solve(A, c)\n","    return(PP)\n","    \n","x = np.array([[0],[8],[16],[24],[32],[40]])\n","y = np.array([[14.621],[11.483],[9.87],[8.418],[7.305],[6.413]])\n","\n","print(\"Estos son los valores de la segunda derivada para los datos: \")\n","print(mat_spline(x,y), \"\\n\")\n","\n","print(\"Ahora toca calcular los Polinomios para los intervalos que requerimos interpolar\")\n","print(\"Usando la forma analitica obtenemos los polinomios: \\n\")\n","\n","print(\"P2 = -0.000952031458*x**3 + 0.04171538*x**2 - 0.776284026667*x + 15.510928\")\n","print(\"P4 = -0.000132130208*x**3 + 0.01412215*x**2 - 0.617081066667*x + 16.9201552 \\n\")\n","\n","def p2(extra1):\n","  p2 = -0.000952031458*extra1**3 + 0.04171538*extra1**2 - 0.776284026667*extra1 + 15.510928\n","  return p2\n","\n","def p4(extra2):\n","  p4 = -0.000132130208*extra2**3 + 0.01412215*extra2**2 - 0.617081066667*extra2 + 16.9201552\n","  return p4\n","\n","print(\"Evaluando en los puntos conocidos para probar nuestros polinomios: \")\n","\n","print(p2(8), \"\\n\", p2(16), \"\\n\")\n","print(\"Y para el P4 \\n\")\n","\n","print(p4(24), \"\\n\", p4(32), \"\\n\")\n","\n","print(\"Finalmente extrapolando en X=10 y X=27 con sus polinomios respectivos\")\n","print(p2(10), \"\\n\", p4(27))\n","\n","print(\"Ahora comparamos con el metodo de Scipy\")\n","\n","x_new = 10\n","x_new2 = 27\n","\n","x = np.array([0,8,16,24,32,40])\n","y = np.array([14.621,11.483,9.87,8.418,7.305,6.413])\n","\n","f = CubicSpline(x, y, bc_type='natural')\n","y_extra1 = f(x_new)\n","y_extra2 = f(x_new2)\n","print(y_extra1,)\n","print(y_extra2, \"\\n\")\n","\n","print(\"Como podemos ver el valor es el mismo, lo que nos idica que esta correcto\")"]}],"metadata":{"colab":{"provenance":[]},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"}},"nbformat":4,"nbformat_minor":0}