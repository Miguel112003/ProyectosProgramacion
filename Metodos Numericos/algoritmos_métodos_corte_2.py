# -*- coding: utf-8 -*-
"""Algoritmos Métodos Corte 2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16x1tjhuThaiRCHU01dji61rhOAo3GxGK
"""

import math
import numpy as np
import scipy
import scipy.linalg
import matplotlib.pyplot as plt
import sympy
from scipy.interpolate import CubicSpline
# En los casos de factorizacion se utiliza Pivoteo Parcial
def menu():
  print("""
  Recuerde que para modificar los valores de todo se debe ir a la linea 440.
  1. Realizar sustitucion hacia atras
  2. Realizar susticion hacia adelante
  3. Hallar Factorizacion LU
  4. Hallar Factorizacion PLU
  5. Hallar Valores Propios
  6. Descomposicion de Cholesky
  7. Norma Vectorial
  8. Norma Matricial
  9. Metodo Gauss-Seidel
  10. Numero Condicional Matriz
  11. Solucion de Sistemas por matriz Inversa
  12. Solucion de sistemas por Numpy Solve
  13. Determinar Matriz Diagonal Dominante
  14. Matriz de Hilbert
  15. Graficar Dispersion de datos
  16. Interpolacion de Newton
  17. Interpolacion de Lagrange
  0. Salir
  """)
  eleccion = int(input("Escoja: "))
  return eleccion

def backsusti(matriz,resultado):
  tamaño = np.shape(matriz)
  n = tamaño[0]
  if tamaño[0] != tamaño[1] :
    print("La matriz no es triangular")
  else:
    print("La matriz es triangular, realizando sustitucion")
    x = np.zeros((n,1))
    x[n-1,0] = resultado[n-1,0] / matriz[n-1,n-1]
    i = n-2
    while i >= 0:
      sumatoria = 0
      j = i + 1
      while j <= n-1:
        sumatoria = sumatoria + matriz[i,j] * x[j,0]
        j += 1
      x[i,0] =  (resultado[i,0] - sumatoria) / matriz[i,i]
      i -= 1
  print("La solucion hallada es: \n")
  return x

def frontsusti(matriz,resultado):
  tamaño = np.shape(matriz)
  n = tamaño[0]
  if tamaño[0] != tamaño [1]:
    print("La matriz no es triangular")
  else:
    print("Realizando sustitucion")
    x = np.zeros((n,1))
    x[0,0] = resultado[0,0] / matriz[0,0]
    i = 1
    while i <= n-1:
      j = 0
      sumatoria = 0
      while j <= n-1:
        sumatoria = sumatoria + matriz[i,j] * x[j,0]
        j +=1
      x[i,0] = (resultado[i,0] - sumatoria) / matriz[i,i]
      i += 1
    return x

def diagonalDominante(matriz):
  n = np.shape(matriz)[0]
  for i in range(0, n) :
    sum = 0
    for j in range(0, n) :
      sum = sum + abs(matriz[i][j])
    sum = sum - abs(matriz[i][i])
    if (abs(matriz[i][i]) < sum) :
      return False
  return True


def diagonalDominanteColumnas(matriz):
  n = np.shape(matriz)[0]
  for i in range(0,n):
    suma = 0
    for j in range(0,n):
      suma = suma + abs(matriz[j,i])
    suma = suma - abs(matriz[i,i])
    if matriz[i,i] < suma :
        print("No es diagonaldominante")
    else:
      print("Es diagonaldominante")


def factolu(matriz):

  if diagonalDominante(matriz) == False:
    if not matriz.shape[0] == matriz.shape[1]:
      raise ValueError("La matriz debe ser cuadrada")
    n = matriz.shape[0]
    L = np.zeros((n,n),dtype='float64')
    U = np.zeros((n,n),dtype='float64')
    U[:] = matriz
    np.fill_diagonal(L,1)
    for i in range(n-1):
      for j in range(i+1,n):
        L[j,i] = U[j,i]/U[i,i]
        U[j,i:] = U[j,i:]-L[j,i]*U[i,i:]
        U[j,i] = 0

    print("Matriz Lower: \n", L, "\n")
    print("Matriz Upper: \n", U, "\n")

    print("Ahora para resolver el sistema post descomposicion usamos Hacia adelante: \n")
    y = frontsusti(L,resultado)
    print(y,"\n")
    print("Matriz original: \n")
    print(np.matmul(L,U), "\n")
    print("Ahora usando el vector que acabamos de obtener resolvemos el sistema Original con hacia atras y la Upper: \n")
    incognitas = backsusti(U, y)

    print(incognitas,"\n")
    print("Esas son las incogitas del sistema\n")
  else:
    print("La matriz no es diagonal Dominante, realice PLU")


def factoplu(matriz,resultado):
  n = np.shape(matriz)[0]
  P, L, U = scipy.linalg.lu(matriz)
  print("Matriz de permutacion: \n", P, "\n")
  print("Matriz Lower: \n", L, "\n")
  print("Matriz Upper: \n", U, "\n")

  #Ahora toca resolver el sistema para lo que calculamos un C
  print("Vector resultado permutado: \n")
  c = np.matmul(P,resultado)
  print(c, "\n")
  # Aqui solucionamos L*INCOGNITAS = C con sustitucion hacia adelante
  print("Vector de incognitas obtenido: \n")
  d = frontsusti(L,c)
  print(d, "\n")
  # Aqui solucionamos U*IncognitasOriginales = d con hacia atras
  print(backsusti(U,d))
  print("Esa es la solucion del sistema original hecho por PLU")

def valorespropios(matriz):
  eigenval,eigenvect = np.linalg.eig(matriz)
  return eigenval

def cholesky(matriz):
  if np.shape(matriz)[0] == np.shape(matriz)[1]:
    print("La matriz es cuadrada")
    iguales = (matriz == np.transpose(matriz)).all()
    if iguales == True:
      print("La matriz es simetrica")
      for i in range (len(valorespropios(matriz))):
        if valorespropios(matriz)[i] >= 0:
          positiva = True
        else:
          positiva = False
  if positiva == True:
    print("Sus valores propios son positivos y reales\n")
    L = np.linalg.cholesky(matriz)
    Lt = np.transpose(L)
    print("La matriz L es: \n", L, "\n")
    print("La matriz L^t es: \n", Lt, "\n")
    print("La matriz original es: \n")
    print(np.matmul(L,Lt),"\n")

    #Ahora toca resolver L*Incognitas = resultado con sustitucion hacia adelante
    y = frontsusti(L,resultado)
    print("El vector de incognitas calculado es: \n",y)
    #Ahora se resuelve el sistema Lt*IncognitasOriginales = IncognitasAnteriores con sustitucion hacia atras
    print(backsusti(Lt,y),"\n")
    print("Esa es la solucion del sistema original, mediante factorizacion Cholesky")


def normavector(vector):
  print("Por si no recuerda, la norma 2 es la norma que uno estudia en Vectores, la raiz de las componentes al cuadrado")
  orden = int(input("Ingrese el orden de la norma (1 o 2) Ponga 3 para norma inf: "))
  if orden == 3:
    orden = np.inf
  print(scipy.linalg.norm(vector,ord=orden))

def normamatriz(matriz):
  print("""Escoja Norma:
  1. Norma 1
  2. Norma Infinita
  3. Norma de Frobenius
  4. Norma 2""")
  eleccion = int(input())
  if eleccion == 3:
    norma = 0
    sumatoria = 0
    i = 1
    while i < n:
      j = 1
      while j < n:
        sumatoria = sumatoria + matriz[i,j]**2
        j += 1
      i += 1
    norma = (sumatoria**(1/2))
    print("La norma matricial 2 es: ")
    return norma
  elif eleccion == 1:
    print("La norma matricial 2 es: ")
    return scipy.linalg.norm(matriz, 1)
  elif eleccion  == 2:
    print("La norma matricial 2 es: ")
    return scipy.linalg.norm(matriz, np.inf)
  else:
    p = np.linalg.eig(np.matmul(matriz,np.transpose(matriz)))
    n = np.shape(np.matmul(matriz,np.transpose(matriz)))[1]
    i = 0
    while i < n-1:
      if abs(p[i]) > abs(p[i-1]):
        maximo = abs(p[i])
      i += 1
    norma = (maximo**(1/2))
    print("La norma matricial 2 es: ")
    return norma

def gauss_seidel(matriz,resultado, condicion):
  print(matriz, "\n")
  print(resultado, "\n")
  n = int(input("Ingrese la cantidad de interaciones: "))
  tolerancia = int(input("Ingrese el exponente de la tolerancia 10^(): "))
  tol = 10**tolerancia
  [n,n]=np.shape(matriz)
  k=1
  while k<=n: # iteraciones
    i=0
    x1=condicion # para aplicar la tolerancia
    while i<=n-1: #hallar los x_i
      su=0
      j=0
      while j<=n-1: #sumatoria
        if i==j:
          su=su
        else:
          su=su+matriz[i,j]*x1[j,0]
        j=j+1
      x1[i,0]=(resultado[i,0]-su)/matriz[i,i]
      i=i+1
    if scipy.linalg.norm(condicion-x1, ord=1)<=tol:
      break
    condicion=x1
    k=k+1
  return(x1)

def numerocondicional(matriz):
  numcond1 = (scipy.linalg.norm(matriz, ord=1) * scipy.linalg.norm(np.linalg.inv(matriz), ord=1))
  numcond2 = (scipy.linalg.norm(matriz, ord=2) * scipy.linalg.norm(np.linalg.inv(matriz), ord=2))
  numcond3 = (scipy.linalg.norm(matriz, ord=np.inf) * scipy.linalg.norm(np.linalg.inv(matriz), ord=np.inf))
  print(numcond1, numcond2, numcond3)
  return numcond1, numcond2, numcond3

def solucioninversa(matriz, resultado):
  inversa = np.linalg.inv(matriz)
  resultado = np.matmul(inversa,resultado)
  print(resultado)
  return resultado

def numpysolve(matriz, resultado):
  solucion = np.linalg.solve(matriz,resultado)
  print(solucion)
  return solucion

def hilbert():
  orden = int(input("Ingrese el tamaño de la matriz: "))
  orden = orden -1
  h = np.eye(orden+1)
  i = 0
  while i < orden+1:
    j = 0
    while j < orden+1:
      h[i,j] = 1/(i+1+j+1-1)
      j += 1
    i += 1

  print("La matriz de hilbert calculada es: \n", h, "\n")
  #Aqui resuelvo el sistema H*Incognitas = Resultado

  matriz = h
  numpysolve(matriz,resultado)
  return h

def graficarDatos(ordenada,abscisa):
  plt.figure(figsize = [6,6], facecolor = "white")
  plt.plot(abscisa,ordenada, "rs", label = "Dispersion de Datos", color = "r")
  plt.xlabel("Eje X")
  plt.ylabel("Eje Y")
  plt.grid()
  plt.legend(title_fontsize = 20, loc = "center left")
  plt.show()

def Linterpol(ordenada,abscisa):
  print("Se va a calcular una interpolacion para los siguientes datos: ")
  graficarDatos(ordenada,abscisa)
  n = np.shape(ordenada)[0]
  L = np.zeros((n,n))
  for c in range(n):
    L[c,0] = 1
  v = 1
  while v < n:
    L[0,v] = 0
    v += 1
  i = 1
  while i < n:
    j = 1
    while j < n:
      k = 0
      productoria = 1
      while k<j:
        productoria *= (abscisa[i]-abscisa[k])
        k += 1
      L[i,j] = productoria
      j += 1
    i += 1
  print("La matriz del polinomio interpolador hallada es: \n")
  print(L, "\n")

  #Ahora toca probar el sistema L*ABSCISA = ORDENADA
  print("Los coeficientes hallados son: ")
  coeficientes = numpysolve(L,ordenada)
  #Ahora sacamos el polinomio interpolador
  x = sympy.Symbol('x')
  i = 1
  polinomio = 0
  while i < n:
    productoria = 1
    j = 0
    while j < i:
      productoria *= (x-abscisa[j])
      j += 1
    polinomio = polinomio + (coeficientes[i] * productoria)
    i += 1
  polinomio = polinomio + coeficientes[0]
  print("El polinomio Interpolador de Newton hallado es: ", polinomio, "\n")
  return polinomio

def extrapolarNewt():
  punto = float(input("Ingrese un valor X para extrapolar: "))
  x = sympy.Symbol('x')
  polinomio = Linterpol(ordenada,abscisa)
  print("El valor extrapolado es: ")
  print(polinomio[0].subs(x,punto))
  seleccion = int(input("Desea graficar el Polinomio para ver si corta al dato? (1. Si, 2. No)"))
  if seleccion == 1:
    a = float(input("Ingrese el primer valor del intervalo a graficar: "))
    b = float(input("Ingrese ell segundo valor del intervalo a graficar: "))
    independientes = np.linspace(a,b,50)
    dependientes = np.zeros_like(independientes)
    for i in range(50):
      dependientes[i] = polinomio[0].subs(x, independientes[i])
    plt.figure(figsize = [6,6], facecolor = "white")
    plt.plot(independientes,dependientes, label = "Polinomio", color = "b")
    plt.xlabel("Eje X")
    plt.ylabel("Eje Y")
    plt.grid()
    plt.legend(title_fontsize = 20, loc = "center left")
    plt.show()
  else:
    return ":D"

def lagrangeinterpol(abscisa, ordenada):
  xp = float(input("Ingrese el valor para extrapolar: "))
  yp = 0

  for xi,yi in zip(abscisa,ordenada):
    #yp += yi * np.prod((xp - x[x != xi])/(xi-x[x != xi]))
  #print('Interpolated value at %.3f is %.3f.' % (xp, yp))
    print("0")
  return 0

def main():
  eleccion = menu()
  if eleccion == 0:
    exit()
  elif eleccion == 1:
    print(backsusti(matriz,resultado))
  elif eleccion == 2:
    print(frontsusti(matriz,resultado))
  elif eleccion == 3:
    factolu(matriz)
  elif eleccion == 4:
    factoplu(matriz,resultado)
  elif eleccion == 5:
    print(valorespropios(matriz))
    print("Toma en cuenta que esos valores propios estan en forma a+b*i, i=raiz(-1)")
    print("Por lo tanto es importante ver si el valor es a+0i, eso significa que es solo real")
  elif eleccion == 6:
    cholesky(matriz)
  elif eleccion == 7:
    normavector(vector)
  elif eleccion == 8:
    normamatriz(matriz)
  elif eleccion == 9:
    print("ESTE METODO LO HICIMOS MAL EN CLASE, NO LO UTILICE, Y USE EL CODIGO DEL BLOQUE SIGUIENTE")
    print(gauss_seidel(matriz,resultado,condicion))
  elif eleccion == 10:
    print("El numero condicional es como la relacion entre los cambios de una variable con su imagen")
    print("Es decir haga de cuenta una funcion f(X) si x cambia poquito y f(x) cambia poquito tambien")
    print("Entonces esta bien condicionada, si cambios pequeños en x generan cambios grandes, mal condicionada")
    print("Esto sirve para relacionar matrices con cambios minimos")
    numerocondicional(matriz)
  elif eleccion == 11:
    solucioninversa(matriz,resultado)
  elif eleccion == 12:
    numpysolve(matriz,resultado)
  elif eleccion == 13:
    print(diagonalDominante(matriz))
  elif eleccion == 14:
    hilbert()
  elif eleccion == 15:
    graficarDatos(ordenada,abscisa)
  elif eleccion == 16:
    opcion = int(input("Quiere extrapolar (Ponga 1) o solo conocer el polinomio? (Ponga 2): "))
    if opcion == 1:
      extrapolarNewt()
    else:
      Linterpol(abscisa, ordenada)
  elif eleccion == 17:
    print(lagrangeinterpol(abscisa, ordenada))
  else:
    print("No tenemos eso, le ofrezco el menu")
    eleccion = menu()


"""Aqui ya tenes que modificar los datos necesarios para el desarrollo de los ejercicios"""

vector = np.array([2,15,-3,1,10,0,2,2])

matriz = np.array([[0,1,1],[1,3,1],[1,1,3]])
resultado = np.array([[12],[16],[-8]])

condicion = np.array([[0],[0],[0]])

abscisa = np.array([[10],[15],[20],[25],[40],[50],[55]])
ordenada = np.array([5,20,18,40,33,54,70])

#Abcisas es X y las ordendas son Y
#La de resultado es el vector al que se iguala un sistema de ecuaciones
#Condicion es el vector de condiciones iniciales para el metodo de Gauss-Seidel ya que este es el que aproxima
#Vector es simplemente un vector como para calcular norma o algo asi
#matriz es la matriz que estas utilizando

#Aqui se ejecuta el codigo

main()

from scipy.interpolate import CubicSpline
import numpy as np


def mat_spline(x,y):
    n=np.shape(x)[0]
    A=np.zeros((n-2,n-2))
    c=np.zeros((n-2,1))
    i=0
    while i<=(n-2)-1:
          j=0
          while j<=(n-2)-1:
                if i==j:
                   A[i,j]=2*(x[i+2,0]-x[i,0])
                elif i==j+1:
                   A[i,j]=x[i+1,0]-x[i,0]
                elif j==i+1:
                   A[i,j]=x[i+2,0]-x[i+1,0]
                j=j+1
          c[i,0]=6/(x[i+2,0]-x[i+1,0])*(y[i+2,0]-y[i+1,0])+6/(x[i+1,0]-x[i,0])*(y[i,0]-y[i+1,0])
          i=i+1
    PP=np.linalg.solve(A, c)
    return(PP)

x = np.array([[0],[8],[16],[24],[32],[40]])
y = np.array([[14.621],[11.483],[9.87],[8.418],[7.305],[6.413]])

print("Estos son los valores de la segunda derivada para los datos: ")
print(mat_spline(x,y), "\n")

print("Ahora toca calcular los Polinomios para los intervalos que requerimos interpolar")
print("Usando la forma analitica obtenemos los polinomios: \n")

print("P2 = -0.000952031458*x**3 + 0.04171538*x**2 - 0.776284026667*x + 15.510928")
print("P4 = -0.000132130208*x**3 + 0.01412215*x**2 - 0.617081066667*x + 16.9201552 \n")

def p2(extra1):
  p2 = -0.000952031458*extra1**3 + 0.04171538*extra1**2 - 0.776284026667*extra1 + 15.510928
  return p2

def p4(extra2):
  p4 = -0.000132130208*extra2**3 + 0.01412215*extra2**2 - 0.617081066667*extra2 + 16.9201552
  return p4

print("Evaluando en los puntos conocidos para probar nuestros polinomios: ")

print(p2(8), "\n", p2(16), "\n")
print("Y para el P4 \n")

print(p4(24), "\n", p4(32), "\n")

print("Finalmente extrapolando en X=10 y X=27 con sus polinomios respectivos")
print(p2(10), "\n", p4(27))

print("Ahora comparamos con el metodo de Scipy")

x_new = 10
x_new2 = 27

x = np.array([0,8,16,24,32,40])
y = np.array([14.621,11.483,9.87,8.418,7.305,6.413])

f = CubicSpline(x, y, bc_type='natural')
y_extra1 = f(x_new)
y_extra2 = f(x_new2)
print(y_extra1,)
print(y_extra2, "\n")

print("Como podemos ver el valor es el mismo, lo que nos idica que esta correcto")