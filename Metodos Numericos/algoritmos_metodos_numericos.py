# -*- coding: utf-8 -*-
"""Algoritmos Metodos Numericos

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YJ9LQTdmqFffWeLwV6MlW3DB121_5k0u
"""

import numpy as np
import matplotlib.pyplot as plt
import math
import random
import sympy
from scipy.optimize import fsolve
from scipy.interpolate import make_interp_spline
# Algoritmos metodos numericos
# Suponemos que todas las funciones son continuas

x = sympy.Symbol('x')
θ = sympy.Symbol('θ')

def menu():
  print("""
  1. Graficar funcion
  2. Aplicar Biseccion
  3. Aplicar Newton-Raphson
  4. Aplicar Secante
  5. Aplicar Falsa Posicion
  6. Usar Fsolve
  7. Calculo Errores
  0. Salir
  """)
  eleccion = int(input("Elija: "))
  return eleccion


def evaluar(abcisa,ordenada,a,b):
  for i in range(round(a),round(b),1):
    ordenada[i] = y.N(10, subs={θ:abcisa[i]})
  return ordenada

def graficar():
  a = float(input("Ingrese el primer dato del intervalo: "))
  b = float(input("Ingrese el segundo dato del intervalo: "))
  abcisa = np.linspace(a,b,round(abs(b-a)))
  ordenada = np.zeros(np.shape(abcisa))

  ordenada = evaluar(abcisa,ordenada,a,b)

  X_Y_Spline = make_interp_spline(abcisa, ordenada)

  X_ = np.linspace(abcisa.min(),abcisa.max(),500)
  Y_ = X_Y_Spline(X_)

  fig, ax = plt.subplots()
  ax.plot(X_,Y_)
  plt.legend(title_fontsize = 20, loc = "upper left")
  plt.xlabel("Eje Horizontal")
  plt.ylabel("Eje Vertical")
  plt.title("Funcion", fontsize = 15, loc = "center")
  plt.grid()
  plt.show()

def biseccion(y):
  a = int(input("Ingrese el primer dato del intervalo: "))
  b = int(input("Ingrese el segundo dato del intervalo: "))
  n = int(input("Ingrese la cantidad de iteraciones a realizar: "))
  potTol = int(input("Ingrese la potencia de la tolerancia: 10^(): "))
  tolerancia = 10**potTol
  if y.subs(x,a) * y.subs(x,b) > 0:
    ap = "Cambie condiciones"
  elif y.subs(x,a) * y.subs(x,b) == 0:
    print("La raiz del polinomio es:")
    if y.subs(x,a) == 0:
      print(y.subs(x,a))
    else:
      print(y.subs(x,b))
  else:
    i = 0
    while i <= n:
      pm = (b + a) / 2
      if y.subs(x,a) * y.subs(x,pm) < 0:
        b = pm
      elif y.subs(x,a)* y.subs(x,pm) == 0:
        ap = pm
        break
      else:
        a = pm
      ap = pm
      i = i + 1
      if abs(b-a) < tolerancia:
        break
    print("La raiz hallada es:", ap, "En la iteracion numero: ",i)

def iteraciones():
  a = float(input("Ingrese el primer dato del intervalo: "))
  b = float(input("Ingrese el segundo dato del intervalo: "))
  potTol = int(input("Ingrese la potencia de la tolerancia: 10^()"))
  tol = 10**potTol
  k = b - a
  var = abs(tol) / k
  n = round(-math.log(var,2))
  return n

def newton(y,derivada):
  print(derivada)
  condicion = float(input("Ingrese el valor inicial: "))
  tol = int(input("Ingrese la potencia de la tolerancia 10^(): "))
  tolerancia = 10**tol
  n = int(input("Ingrese las iteraciones: "))
  if derivada.subs(x,condicion) == 0:
    ap = "Cambie condiciones"
  else:
    i = 1
    while i <= n:
      x1 = condicion - (y.subs(x,condicion)) / derivada.subs(x,condicion)
      ap = x1
      if abs(x1-condicion)< tolerancia:
        break
      condicion = x1
      i += 1
  print("La raiz hallada es: ",ap, "En la iteracion: ",i)

def secante(y):
  condicion1 = float(input("Ingrese la condicion 1: "))
  condicion2 = float(input("Ingrese la condicion 2: "))
  n = int(input("Ingrese la cantidad de iteraciones: "))
  tol = int(input("Ingrese la potencia de la tolerancia 10^(): "))
  tolerancia = 10**tol
  if ((y.subs(x, condicion1)) - (y.subs(x,condicion2))) == 0:
    ap = "Cambie condiciones"
  else:
    i = 1
    while i <= n:
      condicion3 = condicion2 - ((condicion2 - condicion1) * y.subs(x, condicion2)) / (y.subs(x,condicion2)- y.subs(x,condicion1))
      ap = condicion3
      if (abs(condicion3-condicion2)) < tolerancia:
        break
      condicion1 = condicion2
      condicion2 = condicion3
      if i>n:
        print("Metodo falla")
        break
      i = i+1
  print("Las raiz es: ",ap)
  return(ap)
def fakepos(y):
  a = int(input("Ingrese el primer dato del intervalo: "))
  b = int(input("Ingrese el segundo dato del intervalo: "))
  n = int(input("Ingrese la cantidad de iteraciones a realizar: "))
  potTol = int(input("Ingrese la potencia de la tolerancia: 10^(): "))
  tolerancia = 10**potTol
  if y.subs(x,a) * y.subs(x,b) > 0:
    ap = "Cambie condiciones"
  elif y.subs(x,a) * y.subs(x,b) == 0:
    print("La raiz del polinomio es:")
    if y.subs(x,a) == 0:
      print(y.subs(x,a))
    else:
      print(y.subs(x,b))
  else:
    i = 1
    while i <= n:
      condicion3 = b - ((b - a) * y.subs(x, b)) / (y.subs(x,b)- y.subs(x,a))
      ap = condicion3
      if y.subs(x,a) * y.subs(x,b) < 0:
        a = b
        b = condicion3
      else:
        a = a
        b = condicion3
      i += 1
  print("La raiz es: ",ap, "En la iteracion: ",i)

def funsolve(y):
  condicion = float(input("Ingrese la condicion inicial: "))
  root = fsolve(y, condicion)
  print("La raiz es: ", root)

def errorabs(p,q):
  print("El error Absoluto es: ", abs(p-q))

def errorrel(p,q):
  if p == 0:
    print("Erorr, autodestruccion en 5,4,3,2,1")
  else:
    print("El error Relativo es: ", (abs(p-q)/abs(p)))

def hallarq(p,tol):
  q1 = -1*((tol * abs(p)) - p)
  q2 = -1 * (-tol*abs(p)-p)
  print("El valor minimo de P* es: ", q1)
  print("El valor maximo de P* es: ", q2)

def hallarp(q,tol):
  p1 = -1/((-tol-1)/q)
  p2 = -1/((tol-1)/q)
  print("El valor minimo de P es: ",p1)
  print("El valor maximo de P es: ",p2)


def main():
  eleccion = -1
  while eleccion != 0:
    if eleccion == 1:
      graficar()
    elif eleccion == 2:
      print("""
      1. Aplicar metodo de Biseccion
      2. Calcular iteraciones necesarias
      """)
      opcion = int(input("Escoja: "))
      if opcion == 1:
        biseccion(y)
      else:
        print("El numero de iteraciones necesarias son: ",iteraciones())
    elif eleccion == 3:
      newton(y,derivada)
    elif eleccion == 4:
      secante(y)
    elif eleccion == 5:
      fakepos(y)
    elif eleccion == 6:
      funsolve(y)
    elif eleccion == 7:
      print("""
      1. Calculo Error Absoluto
      2. Calculo Error Relativo
      3. Hallar P
      4. Hallar P*
      """)
      opcion = int(input("Escoja: "))

      if opcion == 1:
        errorabs(p,q)
      elif opcion == 2:
        errorrel(p,q)
      elif opcion == 3:
        hallarp(p,tol)
      elif opcion == 4:
        hallarq(q,tol)
      else:
        print("Error Reinicie")
        exit()
    eleccion = menu()



# Escriba Aqui la funcion con la que quiere trabajar f(x)

y = 0.625*sympy.sqrt(1 - 0.2916*sympy.sin(θ)**2)*(729.0*sympy.sin(θ)*sympy.cos(θ)**2 + 729.0*sympy.sin(1)*sympy.cos(θ)**2 + 1771.0*sympy.sin(1) + 20.6192337393997*(-19683.0*(1.0 - sympy.cos(θ)**2)**2 - 30678.6898514262*sympy.sqrt(0.411631846414455*sympy.cos(θ)**2 + 1)*sympy.sin(θ)*sympy.cos(θ)**2 - 9239.46049415652*sympy.sqrt(0.411631846414455*sympy.cos(θ)**2 + 1)*sympy.cos(θ)**2 - 22445.9321469838*sympy.sqrt(0.411631846414455*sympy.cos(θ)**2 + 1) - 87183.0*sympy.cos(θ)**2 + 19683.0)*sympy.cos(θ)**3/(sympy.sqrt(1 - 0.2916*sympy.sin(θ)**2)*(729.0*sympy.cos(2.0*θ) + 4271.0)*sympy.sin(θ + 0.785398163397448)) + 50.091444379255*(-19683.0*(1.0 - sympy.cos(θ)**2)**2 - 30678.6898514262*sympy.sqrt(0.411631846414455*sympy.cos(θ)**2 + 1)*sympy.sin(θ)*sympy.cos(θ)**2 - 9239.46049415652*sympy.sqrt(0.411631846414455*sympy.cos(θ)**2 + 1)*sympy.cos(θ)**2 - 22445.9321469838*sympy.sqrt(0.411631846414455*sympy.cos(θ)**2 + 1) - 87183.0*sympy.cos(θ)**2 + 19683.0)*sympy.cos(θ)/(sympy.sqrt(1 - 0.2916*sympy.sin(θ)**2)*(729.0*sympy.cos(2.0*θ) + 4271.0)*sympy.sin(θ + 0.785398163397448)))/((729.0*sympy.sin(θ)**2 - 2500.0)*sympy.sin(θ)) + 0.27*(1283.33333333333 - 0.675*(729.0*sympy.sin(θ)*sympy.cos(θ)**2 + 729.0*sympy.sin(1)*sympy.cos(θ)**2 + 1771.0*sympy.sin(1) + 20.6192337393997*(-19683.0*(1.0 - sympy.cos(θ)**2)**2 - 30678.6898514262*sympy.sqrt(0.411631846414455*sympy.cos(θ)**2 + 1)*sympy.sin(θ)*sympy.cos(θ)**2 - 9239.46049415652*sympy.sqrt(0.411631846414455*sympy.cos(θ)**2 + 1)*sympy.cos(θ)**2 - 22445.9321469838*sympy.sqrt(0.411631846414455*sympy.cos(θ)**2 + 1) - 87183.0*sympy.cos(θ)**2 + 19683.0)*sympy.cos(θ)**3/(sympy.sqrt(1 - 0.2916*sympy.sin(θ)**2)*(729.0*sympy.cos(2.0*θ) + 4271.0)*sympy.sin(θ + 0.785398163397448)) + 50.091444379255*(-19683.0*(1.0 - sympy.cos(θ)**2)**2 - 30678.6898514262*sympy.sqrt(0.411631846414455*sympy.cos(θ)**2 + 1)*sympy.sin(θ)*sympy.cos(θ)**2 - 9239.46049415652*sympy.sqrt(0.411631846414455*sympy.cos(θ)**2 + 1)*sympy.cos(θ)**2 - 22445.9321469838*sympy.sqrt(0.411631846414455*sympy.cos(θ)**2 + 1) - 87183.0*sympy.cos(θ)**2 + 19683.0)*sympy.cos(θ)/(sympy.sqrt(1 - 0.2916*sympy.sin(θ)**2)*(729.0*sympy.cos(2.0*θ) + 4271.0)*sympy.sin(θ + 0.785398163397448)))/(729.0*sympy.sin(θ)**2 - 2500.0) - 0.3645*sympy.cos(θ)**2/sympy.sqrt(1 - 0.2916*sympy.sin(θ)**2))*sympy.sin(θ) + 0.2025*sympy.sin(θ) + 0.208333333333333*(729.0*sympy.sin(θ)*sympy.cos(θ)**2 + 729.0*sympy.sin(1)*sympy.cos(θ)**2 + 1771.0*sympy.sin(1) + 20.6192337393997*(-19683.0*(1.0 - sympy.cos(θ)**2)**2 - 30678.6898514262*sympy.sqrt(0.411631846414455*sympy.cos(θ)**2 + 1)*sympy.sin(θ)*sympy.cos(θ)**2 - 9239.46049415652*sympy.sqrt(0.411631846414455*sympy.cos(θ)**2 + 1)*sympy.cos(θ)**2 - 22445.9321469838*sympy.sqrt(0.411631846414455*sympy.cos(θ)**2 + 1) - 87183.0*sympy.cos(θ)**2 + 19683.0)*sympy.cos(θ)**3/(sympy.sqrt(1 - 0.2916*sympy.sin(θ)**2)*(729.0*sympy.cos(2.0*θ) + 4271.0)*sympy.sin(θ + 0.785398163397448)) + 50.091444379255*(-19683.0*(1.0 - sympy.cos(θ)**2)**2 - 30678.6898514262*sympy.sqrt(0.411631846414455*sympy.cos(θ)**2 + 1)*sympy.sin(θ)*sympy.cos(θ)**2 - 9239.46049415652*sympy.sqrt(0.411631846414455*sympy.cos(θ)**2 + 1)*sympy.cos(θ)**2 - 22445.9321469838*sympy.sqrt(0.411631846414455*sympy.cos(θ)**2 + 1) - 87183.0*sympy.cos(θ)**2 + 19683.0)*sympy.cos(θ)/(sympy.sqrt(1 - 0.2916*sympy.sin(θ)**2)*(729.0*sympy.cos(2.0*θ) + 4271.0)*sympy.sin(θ + 0.785398163397448)))/((729.0*sympy.sin(θ)**2 - 2500.0)*sympy.sin(θ)) + 0.00572756492761104*(-19683.0*(1.0 - sympy.cos(θ)**2)**2 - 30678.6898514262*sympy.sqrt(0.411631846414455*sympy.cos(θ)**2 + 1)*sympy.sin(θ)*sympy.cos(θ)**2 - 9239.46049415652*sympy.sqrt(0.411631846414455*sympy.cos(θ)**2 + 1)*sympy.cos(θ)**2 - 22445.9321469838*sympy.sqrt(0.411631846414455*sympy.cos(θ)**2 + 1) - 87183.0*sympy.cos(θ)**2 + 19683.0)*sympy.cos(θ)/(sympy.sqrt(1 - 0.2916*sympy.sin(θ)**2)*(729.0*sympy.cos(2.0*θ) + 4271.0)*sympy.sin(θ + 0.785398163397448)) - 0.091125*sympy.sin(θ)*sympy.cos(θ)/(0.25 - 0.0729*sympy.sin(θ)**2)

derivada = sympy.diff(y,θ,1)

#Escriba Aqui los valores de error necesarios

p = math.log(2)
q = 0.75
tol = 10**-5

main()

def punto3(x,n):
  i = 0
  resultado = 0
  while i<=n:
    resultado = resultado + (-1)**i * (x**(2*i) / math.factorial(2*i))
    i += 1
  return resultado

def errorrel(p,q):
  if p == 0:
    print("Erorr, autodestruccion en 5,4,3,2,1")
  else:
    print("El error Relativo es: ", (abs(p-q)/abs(p)))

q = punto3(2,7)
print("La aproximacion obtenida es: ", q)
p = math.cos(2)

errorrel(p,q)

import numpy as np
x = np.linspace(10,50,40)

def funcion(x):
  funcion = 2000 * np.log(150000/(150000-2700*x))-9.81*x -750
  return funcion

plt.figure(figsize=[6,6])
plt.plot(x,funcion(x))
plt.show()